#version 460

#define DEPTH_SSBO_QUALIFIERS restrict
#include "depth_ssbo.glsl"
#define CASCADE_SSBO_QUALIFIERS restrict writeonly
#include "cascade_ssbo.glsl"
#include "shadow_setting_uniforms.glsl"

layout(local_size_x = 4) in;

layout(location = Z_PARTITION_COMP_SHADOW_MAP_RES_LOCATION)
    uniform uint shadow_map_res;
layout(location = Z_PARTITION_COMP_CAMERA_NEAR_PLANE_LOCATION)
    uniform float camera_near_plane;
layout(location = Z_PARTITION_COMP_CAMERA_FAR_PLANE_LOCATION)
    uniform float camera_far_plane;
layout(location = Z_PARTITION_COMP_PROJ_VIEW_INV_LOCATION)
    uniform mat4 proj_view_inv;
layout(location = Z_PARTITION_COMP_LIGHT_VIEW_LOCATION)
    uniform mat4 light_view;

shared float partition_planes[5];

#define DEFINE_DISCRETIZE(type)                       \
    type discretize(const type v, const float step) { \
        return floor(v / step) * step;                \
    }

DEFINE_DISCRETIZE(vec2)

struct BoundingBox {
    vec3 min_corner;
    vec3 max_corner;
};

mat4 ortho(BoundingBox bounding_box) {
    const vec3 neg_diff_inv = 1.0f / (bounding_box.min_corner - bounding_box.max_corner);
    const vec3 sum = bounding_box.min_corner + bounding_box.max_corner;
    return mat4(
        -2.0f * neg_diff_inv.x, 0.0f, 0.0f, 0.0f,
        0.0f, -2.0f * neg_diff_inv.y, 0.0f, 0.0f,
        0.0f, 0.0f, 2.0f * neg_diff_inv.z, 0.0f,
        sum * neg_diff_inv, 1.0f);
}

float DistanceToDepth(const float distance) {
    return (distance - camera_near_plane) / (camera_far_plane - camera_near_plane) * camera_far_plane / distance;
}

float DepthToDistance(const float depth) {
    return 1.0f / mix(1.0f / camera_near_plane, 1.0f / camera_far_plane, depth);
}

vec3 projToWorld(const vec3 p) {
    vec4 w = proj_view_inv * vec4(p, 1.0f);
    w /= w.w;
    return w.xyz;
}

float GetFrustrumDiag(const float near_plane, const float far_plane) {
    const float near_depth = 2.0f * DistanceToDepth(near_plane) - 1.0f;
    const float far_depth = 2.0f * DistanceToDepth(far_plane) - 1.0f;
    const vec3 v0 = projToWorld(vec3(1.0f, 1.0f, far_depth));
    const vec3 v1 = projToWorld(vec3(-1.0f, -1.0f, far_depth));
    const vec3 v2 = projToWorld(vec3(-1.0f, -1.0f, near_depth));
    const float d1 = length(v1 - v0);
    const float d2 = length(v2 - v0);
    return max(d1, d2);
}

BoundingBox getBoundingBox(const float near_plane, const float far_plane) {
    BoundingBox box = BoundingBox(vec3(1.0f / 0.0f), vec3(-1.0f / 0.0f));

    const float planes[2] = {near_plane, far_plane};

    for (int x = 0; x < 2; x++) {
        for (int y = 0; y < 2; y++) {
            for (int z = 0; z < 2; z++) {
                const float zNDC = 2.0f * DistanceToDepth(planes[z]) - 1.0f;
                const vec3 worldP = projToWorld(vec3(2 * x - 1, 2 * y - 1, zNDC));
                vec3 viewP = (light_view * vec4(worldP, 1.0f)).xyz;
                viewP.z *= -1.0f;
                box.min_corner = min(box.min_corner, viewP);
                box.max_corner = max(box.max_corner, viewP);
            }
        }
    }

    return box;
}

void Partition() {
    const uint i = gl_LocalInvocationIndex;
    const float min_plane = (b_shadow_cascade_depth_adjust) ? DepthToDistance(uintBitsToFloat(minDepth)) - 0.01f : camera_near_plane;
    const float max_plane = (b_shadow_cascade_depth_adjust) ? DepthToDistance(uintBitsToFloat(maxDepth)) : camera_far_plane;
    partition_planes[i] = pow(max_plane / min_plane, i * 0.25f) * min_plane;
    if (i == 0) {
        partition_planes[4] = max_plane;
    }
    memoryBarrierShared();
    barrier();
}

void main() {
    const uint i = gl_LocalInvocationIndex;

    Partition();

    const float n = partition_planes[i];
    const float f = partition_planes[i + 1];
    BoundingBox bounding_box = getBoundingBox(n, f);
    if (b_shadow_texel_move) {
        const float boundingBoxSize = GetFrustrumDiag(n, f) * (shadow_map_res + 1.0f) / shadow_map_res;
        bounding_box.min_corner.xy = discretize(bounding_box.min_corner.xy, boundingBoxSize / shadow_map_res);
        bounding_box.max_corner.xy = bounding_box.min_corner.xy + vec2(boundingBoxSize);
        cascadeSampleSizes[i] = boundingBoxSize / shadow_map_res;
    } else {
        const vec2 d = bounding_box.max_corner.xy - bounding_box.min_corner.xy;
        cascadeSampleSizes[i] = max(d.x, d.y) / shadow_map_res;
    }
    const mat4 light_proj = ortho(bounding_box);

    cascadeTransforms[i] = light_proj * light_view;
    cascadeDepths[i] = DistanceToDepth(n);

    if (b_shadow_cascade_depth_adjust) {
        if (i == 0) {
            minDepth = floatBitsToUint(1.0f);
            maxDepth = floatBitsToUint(0.0f);
        }
    }
}
