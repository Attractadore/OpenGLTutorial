#version 460

layout(local_size_x = 4) in;

layout(binding = 0) restrict readonly buffer CascadePlanesBuffer {
    uint minPlane;
    uint maxPlane;
};

layout(binding = 1) restrict writeonly buffer CascadePropertiesBuffer {
    mat4 cascadeTransforms[4];
    vec4 cascadeDepths;
    vec4 cascadeSampleSizes;
};

shared float partition_planes[5];

layout(location = 0) uniform uint shadow_map_res;
layout(location = 3) uniform float camera_near_plane;
layout(location = 4) uniform float camera_far_plane;
layout(location = 5) uniform mat4 camera_proj_view_inv;
layout(location = 10) uniform mat4 light_view;

#define DEFINE_DISCRETIZE(type) \
type discretize(type v, float step) { \
    return floor(v / step) * step; \
}

DEFINE_DISCRETIZE(vec2)

mat4 ortho(float left, float right, float bottom, float top, float near, float far) {
    return mat4(
        2.0f / (right - left), 0.0f, 0.0f, (left + right) / (left - right),
        0.0f, 2.0f / (top - bottom), 0.0f, (bottom + top) / (bottom - top),
        0.0f, 0.0f, 2.0f / (far - near),   (near + far) / (near - far),
        0.0f, 0.0f, 0.0f, 1.0f
    );
}

float DistanceToDepth(float distance) {
    return (distance - camera_near_plane) / (camera_far_plane - camera_near_plane) * camera_far_plane / distance;
}

float GetFrustrumDiag(float near_plane, float far_plane) {
    vec3 v0 = far_plane * edge_dir_vec;
    vec3 v1 = vec3(-v0.xy, v0.z);
    vec3 v2 = near_plane * edge_dir_vec;

    float d10 = length(v0 - v1);
    float d12 = length(v2 - v1);

    return max(d10, d12);
}

mat4 GetLightProj(float boxSize, float near_plane, float far_plane) {
    vec3 minBox = vec3(1.0f / 0.0f);
    vec3 maxBox = vec3(-1.0f / 0.0f);

    float z_scalars[2] = {near_plane, far_plane};

    for (int x = 0; x < 2; x++) {
        for (int y = 0; y < 2; y++) {
            for (int z = 0; z < 2; z++) {
                vec3 worldP = camera_pos + edge_dir_vec * vec3(2 * x - 1, 2 * y - 1, 1) * z_scalars[z];
                vec3 viewP = (light_view * vec4(worldP, 1.0f)).xyz;
                viewP.z *= -1.0f;
                maxBox = max(maxBox, viewP);
                minBox = min(minBox, viewP);
            }
        }
    }

    minBox.xy = discretize(minBox.xy, boxSize / shadow_map_res);
    maxBox.xy = minBox.xy + vec2(boxSize);

    mat4 light_proj = ortho(minBox.x, maxBox.x, minBox.y, maxBox.y, minBox.z, maxBox.z);

    return light_proj;
} 

void Partition() {
    const uint i = gl_LocalInvocationIndex;
    float f_max_plane = maxPlane / float(-1U);
    float f_min_plane = minPlane / float(-1U);
    partition_planes[i] = pow(float(maxPlane) / float(minPlane), i * 0.25f) * f_min_plane;
    if (i == 0) {
        partition_planes[4] = maxPlane;
    }
    memoryBarrierShared();
    barrier();
}

void main() {
    const uint i = gl_LocalInvocationIndex;

    Partition();

    const float n = partition_planes[i];
    const float f = partition_planes[i + 1];
    const float boundingBoxSize = GetFrustrumDiag(n, f) * (shadow_map_res + 1.0) / shadow_map_res;
    const mat4 light_proj = GetLightProj(boundingBoxSize, n, f);

    cascadeTransforms[i] = light_proj * light_view;
    cascadeDepths[i] = DistanceToDepth(n);
    cascadeSampleSizes[i] = boundingBoxSize / shadow_map_res;
}

